import sys
import pandas as pd
import pkg_resources
import copy
import subprocess

import sctoolbox.utilities as utils


def read_scsa_database(species):
    """ Read the SCSA database and return gene names and ids

    Parameters
    -----------
    species : str
        Species to read genes for. Must be one of Mouse or Human """

    marker_path = pkg_resources.resource_filename("sctoolbox", "data/scsa.tsv")
    cmarkers = pd.read_csv(marker_path, sep="\t")

    # Subset to species
    cmarkers = cmarkers[cmarkers["speciesType"] == species]

    # Read gene names and ids
    gene_names = cmarkers["gene"].tolist()
    gene_ids = cmarkers["ensemblID"].tolist()

    return gene_names, gene_ids


def get_rank_genes(d):
    """ Get a list of unique rank genes from the nested adata.uns["rank_genes_groups"] dictionary

    Parameters
    -----------
    d : dictionary
        The dictionary in adata.uns["rank_genes_groups"]

    Returns
    --------
    A list of unique gene names from  adata.uns["rank_genes_groups"]['names']
    """

    names_dict = {}  # collect names in a dict to remove duplicates
    for lst in d["names"]:
        for name in lst:
            names_dict[name] = ""

    genes = list(names_dict.keys())
    return genes


def check_genes_databses(all_genes, gene_db, source):
    """ Check the coverage of genes between a database and a list of genes

    Parameters
    -----------
    all_genes : list
        List of input genes without duplicates
    genes_db : list
        List of marker genes
    source : str
        Where genes_db originated from: wholeDB or user_db
    """

    # Check the overlap between input genes and database
    gene_overlap = set(all_genes).intersection(gene_db)
    if len(gene_overlap) == 0:
        raise ValueError(f"No match found between input genes and {source} database. Adjust 'gene_column' to control input genes and 'gene_symbol' to control the switch between name/id.")
    perc_overlap = round(len(gene_overlap) / len(all_genes) * 100, 1)
    perc_db_coverage = round(len(gene_overlap) / len(gene_db) * 100, 1)
    print(f"{len(gene_overlap)}/{len(all_genes)} ({perc_overlap}%) input genes were found in {source} database (total genes in database: {len(gene_db)})")
    print(f"{len(gene_overlap)}/{len(gene_db)} ({perc_db_coverage}%) of genes in {source} database were used for annotation")


def run_scsa(adata,
             gene_column=None,
             gene_symbol='auto',
             key='rank_genes_groups',
             column_added='SCSA_pred_celltype',
             inplace=True,

             python_path=None,
             scsa_path=None,
             wholedb_path=None,
             species='human',
             fc=1.5,
             pvalue=0.01,
             tissue='All',
             celltype='normal',
             user_db=None,
             z_score='best',
             ):
    """
    A function to run SCSA cell type annotation and assign cell types to cluster in an adata object.

    This is a wrapper function that extracts ranked genes generated by scanpy.tl.rank_genes_groups
    function and generates input matrix for SCSA, then runs SCSA and assigns cell types to clusters
    in adata.obs.

    Also adds adata.uns['SCSA'] as a dictionary with the following keys:
    - 'results': SCSA result table
    - 'go': GO-term result table
    - 'stderr': SCSA stderr
    - 'stdout': SCSA stdout
    - 'cmd': SCSA command

    Note:
    ------
    SCSA sometimes gives ValueError: MultiIndex (as covered in https://github.com/bioinfo-ibms-pumc/SCSA/issues/19).
    This can be solved by downgrading pandas to 1.2.4.

    Function parameters
    --------------------
    adata : anndata.AnnData
        Adata object to be annotated, must contain ranked genes in adata.uns
    gene_column : str, optional
        Name of the column in adata.var that contains the gene names. Default: None (takes the index of adata.var)
    gene_symbol : str, optional
        The type of gene symbol. One of "auto", "symbol" (gene name) or "id" (ensembl id). Defaults to 'auto'.
    key : str, optional
        The key in adata.uns where ranked genes are stored. Defaults to 'rank_genes_groups'.
    column_added : str, optional
        The column name in adata.obs where the cell types will be added. Defaults to 'SCSA_pred_celltypes'.
    inplace : bool, optional
        If True, cell types will be added to adata.obs. Defaults to True.

    SCSA parameters
    ----------------
    python_path : str, optional
        Path to python. If not given, will be inferred from sys.executable.
    scsa_path : str, optional
        Path to SCSA.py. Default is to use the SCSA.py file in the sctoolbox/data folder.
    wholedb_path : str, optional
        Path to whole.db. Default is to use the whole.db file in the sctoolbox/data folder.
    species : str, optional
        Supports only human or mouse. Defaults to 'human'.
    fc : float, optional
        Fold change threshold to filter genes. Defaults to 1.5.
    pvalue : float, optional
        P value threshold to filter. Defaults to 0.01.
    tissue : float, optional
        A specific tissue can be defined. Defaults to 'All'.
    celltype : str, optional
        Either normal or cancer. Defaults to 'normal'.
    user_db : str, optional
        Path to the user defined marker database. Defaults to None.
    z_score : str, optional
        Whether to choose the best scoring cell type. Defaults to 'best'.

    Returns
    --------
        AnnData: If inplace==False, returns adata with cell types in adata.obs
    """

    if species:
        species = species.capitalize()

    # ---- checking if columns exist in adata ---- #
    if key not in adata.uns.keys():
        raise KeyError(f'{key} was not found in adata.uns! Run rank_genes_groups first')

    # Get groupby from adata.uns
    try:
        groupby = adata.uns[key]['params']['groupby']
    except Exception:
        raise KeyError(f"Could not find 'params' within adata.uns[{key}]. Please ensure that this key contains results of rank_genes_groups.")

    # Check species and user.db
    if species not in ['Human', 'Mouse', None]:
        raise ValueError('Supported species are only: human or mouse! To annotate other species, set species=None and provide a user_db')
    if not user_db and not species:
        raise ValueError('If no species is provided, user_db must be given! Supported species are: human or mouse! If you want to annotate other species, please provide a marker genes list using the parameter: user_db')

    # Get paths to scripts and files
    if not python_path:
        python_path = sys.executable
    if not scsa_path:
        scsa_path = pkg_resources.resource_filename("sctoolbox", "data/SCSA.py")
    if not wholedb_path:
        wholedb_path = pkg_resources.resource_filename("sctoolbox", "data/whole.db")

    # ---- fetching ranked genes from adata.uns ---- #
    result = copy.deepcopy(adata.uns[key])
    if gene_column is not None:

        # gene_column must be in adata.var
        if gene_column not in adata.var.columns:
            raise KeyError(f'{gene_column} was not found in adata.var')

        # Translate index names to names from gene_column
        idx2name = dict(zip(adata.var.index, adata.var[gene_column]))
        for i in range(len(result["names"])):
            for j in range(len(result["names"][i])):
                result["names"][i][j] = idx2name[result["names"][i][j]]

    # ---- Find out which gene symbol to use ---- #
    all_genes = get_rank_genes(result)
    print("Found {} genes from input ranked genes".format(len(all_genes)))
    print("Checking if genes are in the database...")
    if species is not None:
        database_genes_symbol, database_genes_id = read_scsa_database(species)
        symbol_overlap = set(all_genes).intersection(database_genes_symbol)
        id_overlap = set(all_genes).intersection(database_genes_id)

        # If gene_symbol is 'auto', try to infer column from database
        if gene_symbol == 'auto':
            print(f"gene symbol overlap: {len(symbol_overlap)} | ensembl id overlap: {len(id_overlap)}")

            if len(symbol_overlap) == 0 and len(id_overlap) == 0:
                raise ValueError("No match found between input genes and marker database. Adjust'gene_column' to control input genes.")
            if len(symbol_overlap) >= len(id_overlap):
                print("Auto detection: gene_symbol is set to 'symbol'")
                gene_symbol = "symbol"
            else:
                print("Auto detection: gene_symbol is set to 'id'")
                gene_symbol = "id"

        # Fetch final database genes
        if gene_symbol == "symbol":
            database_genes = database_genes_symbol
        else:
            database_genes = database_genes_id

        # check database_genes against all_genes
        check_genes_databses(all_genes, database_genes, source='wholeDB')

    if user_db is not None:
        # Read user database and check overlap with input genes
        user_database = pd.read_csv(user_db, sep="\t", header=None)
        database_genes = set(user_database[1].tolist())

        # check database_genes against all_genes
        check_genes_databses(all_genes, database_genes, source='User DB')

    # ---- Setup table for SCSA input ---- #
    groups = result['names'].dtype.names
    dat = pd.DataFrame({group + '_' + key[:1]: result[key][group] for group in groups for key in ['names', 'logfoldchanges', 'scores', 'pvals']})

    # Fill duplicate genes with _NA
    name_columns = [col for col in dat if col.endswith("_n")]
    for col in name_columns:
        dups = dat[col].duplicated(keep='first')
        dat[col].mask(dups, other="_NA", inplace=True)  # replace all duplicates with _NA

    # Save to file
    csv = './scsa_input.csv'
    dat.to_csv(csv)

    # ---- building the SCSA command ---- #
    results_path = "./scsa_results.txt"
    utils.create_dir(results_path)  # make sure the full path to results exists

    if species == 'Human' or species == 'Mouse':
        scsa_cmd = f"{python_path} {scsa_path} -d {wholedb_path} -i {csv} -s scanpy -k {tissue} -b -g {species} -f {fc} -p {pvalue} -o {results_path} -m txt"

        if gene_symbol == "symbol":
            scsa_cmd += ' -E'
        if user_db:
            scsa_cmd += f' -M {user_db}'

    else:
        # annotating other species is possible if species is False and user_db is provided
        scsa_cmd = f"{python_path} {scsa_path} -d {wholedb_path} -i {csv} -s scanpy -k {tissue} -b -f {fc} -p {pvalue} -o {results_path} -m txt -M {user_db} -N"

        if gene_symbol == "symbol":
            scsa_cmd += ' -E'

    # ---- run SCSA command ---- #
    print('Running SCSA...\n')
    p = subprocess.run(scsa_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stderr = p.stderr
    stdout = p.stdout
    if p.returncode != 0:
        raise ValueError(f"SCSA failed with error: {stderr.decode('utf-8')}")

    # ---- read results_path and assign to adata.obs ---- #
    if z_score == 'best':
        df = pd.read_csv(results_path, sep='\t', engine='python')
        adata.uns["SCSA"] = df

        # Save the celltype with the best z-score to adata.obs
        df_max1 = df.groupby('Cluster').first()
        df_max = df_max1.drop(columns=['Z-score'])
        df_max = df_max.reset_index()
        df_max = df_max.rename(columns={'Cell Type': 'Cell_Type'})
        df_max = df_max.astype(str)
        dictMax = dict(zip(df_max.Cluster, df_max.Cell_Type))

    print(f"Done. Best scoring celltype was added to '{column_added}' and the full results were added to adata.uns['SCSA']")
    for _, row in df.drop_duplicates(subset='Cluster', keep='first').iterrows():
        print(f"Cluster {row['Cluster']} was annotated with celltype: {row['Cell Type']}")

    # Read the go-term output file
    go = pd.read_csv(results_path + ".go", sep="\t")

    # Save results to uns dictionary
    scsa_uns_dict = {"SCSA": {"results": df,
                              "go": go,
                              "stderr": stderr.decode('utf-8'),
                              "stdout": stdout.decode('utf-8'),
                              "cmd": scsa_cmd}}

    # Remove the temporary files
    files = [csv, results_path, results_path + ".go"]
    utils.remove_files(files)

    # Add the annotated celltypes to the anndata-object
    if inplace:
        adata.obs[column_added] = adata.obs[groupby].map(dictMax)
        adata.uns.update(scsa_uns_dict)
    else:
        assigned_adata = adata.copy()
        assigned_adata.obs[column_added] = assigned_adata.obs[groupby].map(dictMax)
        assigned_adata.uns.update(scsa_uns_dict)
        return assigned_adata
